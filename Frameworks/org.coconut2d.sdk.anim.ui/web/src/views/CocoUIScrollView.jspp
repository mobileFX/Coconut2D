/* ***** BEGIN LICENSE BLOCK *****
 *
 * Copyright (C) 2013-2017 www.mobilefx.com
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * ***** END LICENSE BLOCK ***** */

#pragma export_native;
#pragma export_web;

// ==================================================================================================================================
//	   ______                 __  ___________                 _____    ___
//	  / ____/___  _________  / / / /  _/ ___/______________  / / / |  / (_)__ _      __
//	 / /   / __ \/ ___/ __ \/ / / // / \__ \/ ___/ ___/ __ \/ / /| | / / / _ \ | /| / /
//	/ /___/ /_/ / /__/ /_/ / /_/ // / ___/ / /__/ /  / /_/ / / / | |/ / /  __/ |/ |/ /
//	\____/\____/\___/\____/\____/___//____/\___/_/   \____/_/_/  |___/_/\___/|__/|__/
//
// ==================================================================================================================================

#include "CocoUIView.jspp"

class CocoUIScrollView : CocoUIView
{
	private var __scrollLastTime:Time;
	private var __scrollFirstPointY:Float;
	private var __scrollLastPointY:Float;
	private var __scrollSpeedY:Float;
	private var __minY:Float;
	private var __maxY:Float;
	private var __bounceY:Boolean;
	private var __scrollContainer:CocoUIView;
	private var __scrollDeceleration:Float;
	private var __scrollSpringTension:Float;

	////////////////////////////////////////////////////////////////////////////////////////////////////
 	public function Constructor(scene:CocoScene, name:String) : CocoUIView(scene, name)
 	{
		__instanceName 			= name;
		__scrollSpeedY 			= 0.0;
		__minY 					= 0;
		__maxY 					= 0;
		__bounceY 				= false;
		__scrollDeceleration 	= 0.95;
		__scrollSpringTension 	= 16.0;
		__scrollLastTime 		= 0;
		__scrollFirstPointY 	= 0.0;
		__scrollLastPointY 		= 0.0;
		__scrollContainer 		= null;

		// Add a container clip to place all children so that
		// during scrolling we only scroll this container.
 		__scrollContainer = new CocoUIView(scene, "__scrollContainer");
 		__scrollContainer.__timeline.clear();
		__scrollContainer.__timeline.addKeyFrameEx(null, null, 0, COCO_KEYFRAME_INTERPOLATION_ENUM.KEYFRAME_INTERPOLATION_ECHO, false, true, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, null, false, false, '', 0, 0, 0, 1, 1);
 		super.addChild(__scrollContainer);

 		// We need to be able to handle events
 		__timeline.keyFrame(0).handleEvents = true;
		addEventListener(this.OnTouchStart, __CocoUIScrollView_OnTouchStart);
 		addEventListener(this.OnTouchMove, __CocoUIScrollView_OnTouchMove);
 		addEventListener(this.OnTouchEnd, __CocoUIScrollView_OnTouchEnd);
 	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
 	public function Destructor()
 	{
 		removeEventListener(this.OnTouchStart, __CocoUIScrollView_OnTouchStart);
 		removeEventListener(this.OnTouchMove, __CocoUIScrollView_OnTouchMove);
 		removeEventListener(this.OnTouchEnd, __CocoUIScrollView_OnTouchEnd);

 		delete __scrollContainer;
 	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
 	public function stackedChildren():Array<CocoClip>
 	{
 		return __scrollContainer.__children;
 	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
 	published property ScrollDeceleration
 	{
 		function get():Float { return __scrollDeceleration; }
 		function set(v:Float) { __scrollDeceleration = v; }
 	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	published property ScrollSpringTension
 	{
 		function get():Float { return __scrollSpringTension; }
 		function set(v:Float) { __scrollSpringTension = v; }
 	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function getKeyFrame() :CocoKeyFrame
	{
		return __scrollContainer.__timeline.keyFrame(0);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function inlineHeight() :Integer
	{
		var h:Integer = 0;
		var ctl:CocoUIControl;
		var L:Integer = __scrollContainer.__children.size();
		for(var i:Integer=L;i--;)
		{
			ctl = CocoUIControl(__scrollContainer.__children[i]);
			if(!ctl.Visible) continue;
			if(i<L-1 && CocoUIControl(__scrollContainer.__children[i+1]).__stacked!=STACKED_SIBLING)
				h += ctl.MarginTop + ctl.Height + ctl.MarginBottom;
		}
		__maxY = Math.min(__minY, Height - h);
		__scrollContainer.Height = h;
		__scrollContainer.Width = Width;
		return h;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function resetSelection()
	{
		var ctl:CocoUIControl;
		for(var i:Integer=__scrollContainer.__children.size();i--;)
		{
			ctl = CocoUIControl(__scrollContainer.__children[i]);
			ctl.Selected = false;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public virtual function addChild(ctl:CocoUIControl) :CocoUIControl
	{
		__scrollContainer.addChild(ctl);
		ctl.Width = Width - ctl.MarginLeft - ctl.MarginRight;
		ctl.RefreshLayout(this);
		inlineHeight();
		return ctl;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function getControlByName(id:String) :CocoUIControl
	{
		return CocoUIControl(__scrollContainer.getChildByName(id));
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public virtual function RefreshLayout(parent:CocoUIView)
	{
		if(parent)
		{
			__scene = parent.__scene;
			__form = CocoUIFormView(parent);
		}

		if(__scene)
		{
			var h:Float = 0;
			var ctl:CocoUIControl;
			var L:Integer = __scrollContainer.__children.size();

			for(var i:Integer=0; i<L; i++)
			{
				ctl = CocoUIControl(__scrollContainer.__children[i]);

				// Set control width
				ctl.Width = Width - ctl.MarginLeft - ctl.MarginRight;
				ctl.RefreshLayout(this);

				// Translate control's position from top-left origin to parent's center.
				ctl.__timeline.translateTo( -Width/2 + ctl.MarginLeft + ctl.Width/2, -Height/2 + (h+ctl.MarginTop) + ctl.Height/2);

				if(i<L-1 &&  CocoUIControl(__scrollContainer.__children[i+1]).__stacked != STACKED_SIBLING)
				{
					if(ctl.Visible)
						h += ctl.MarginTop + ctl.Height + ctl.MarginBottom;
				}
			}

			inlineHeight();
		}

		__invalidated = false;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
 	public virtual function paint(ctx:ICocoRenderContext, scene:CocoScene, parentClip:CocoClip, calcBoundingBox:Boolean, level:Integer, index:Integer)
 	{
 		var KF:CocoKeyFrame = getKeyFrame();

 		__scrollSpeedY *= __scrollDeceleration;

 		KF.y += __scrollSpeedY;

 		if(__bounceY)
 		{
	 		var springY:Float = __minY - KF.y;
	 		if(springY < 0.0)
	 		{
	 			__scrollSpeedY *= __scrollDeceleration;
				KF.y += -springY / -Math.sqrt(-springY);
				if(KF.y < __minY)
				{
					KF.y = __minY;
					__bounceY = false;
					__scrollSpeedY = 0.0;
				}
	 		}
	 		else
	 		{
		 		var springY:Float = __maxY - KF.y;
		 		if(springY > 0.0)
		 		{
		 			__scrollSpeedY *= __scrollDeceleration;
		 			KF.y += springY / Math.sqrt(springY);
		 			if(KF.y > __maxY)
		 			{
		 				KF.y = __maxY;
		 				__bounceY = false;
		 				__scrollSpeedY = 0.0;
		 			}
		 		}
	 		}
 		}

 		KF.y = Math.round(KF.y);

 		super.paint;
 	}

 	////////////////////////////////////////////////////////////////////////////////////////////////////
 	public function __CocoUIScrollView_OnTouchStart(sender:CocoEventSource, e:CocoEvent, x:Float, y:Float) :Boolean
	{
		__scrollFirstPointY = y;
		__scrollLastTime = engine.__clock;
		__scrollLastPointY = y;
		__scrollSpeedY = 0.0;
		return false;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function __CocoUIScrollView_OnTouchMove(sender:CocoEventSource, e:CocoEvent, x:Float, y:Float) :Boolean
	{
		var KF:CocoKeyFrame = getKeyFrame();

		var dY:Float = (y - __scrollLastPointY) / __scene.ViewScale;
		var sY:Float = 1.0;
 		var springY:Float = __minY - KF.y;
 		if(springY < 0.0)
 		{
			sY = Height / (Height - springY * __scrollSpringTension);
 		}
 		else
 		{
	 		var springY:Float = __maxY - KF.y;
	 		if(springY > 0.0)
	 		{
	 			sY = Height / (Height + springY * __scrollSpringTension);
	 		}
 		}

		if(Math.abs(__scrollFirstPointY-y)>COCO_CONTROL_MOVE_SNAP_PIXELS)
 			resetSelection();

		KF.y += dY * sY;

		__scrollLastTime = engine.__clock;
		__scrollLastPointY = y;
		return false;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function __CocoUIScrollView_OnTouchEnd(sender:CocoEventSource, e:CocoEvent, x:Float, y:Float) :Boolean
	{
		var dY:Float = (y - __scrollLastPointY) / __scene.ViewScale;
		__scrollSpeedY = dY;
		__bounceY = true;
		resetSelection();
		return false;
	}
}
